package generator

import (
	"bytes"
	"encoding/json"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
	"text/template"
)

type CountryWrapper struct {
	Countries []Country `json:"3166-1"`
}

type Country struct {
	Alpha2       string `json:"alpha_2"`
	Alpha3       string `json:"alpha_3"`
	Name         string `json:"name"`
	OfficialName string `json:"official_name"`
	CommonName   string `json:"common_name"`
	Numeric      string `json:"numeric"`
	Child        map[string]SubDivision
}

type SubDivisionWrapper struct {
	SubDivisions []SubDivision `json:"3166-2"`
}

type SubDivision struct {
	Name   string `json:"name"`
	Code   string `json:"code"`
	Parent string `json:"parent"`
	Type   string `json:"type"`
	Child  map[string]SubDivision
}

func parseFile(filename string, s interface{}) {
	if err := json.Unmarshal(readFile(filename), &s); err != nil {
		panic(err)
	}
}

func readFile(fileName string) []byte {
	dat, err := ioutil.ReadFile(fileName)
	if err != nil {
		panic(err)
	}
	return dat
}

func SlicesToMap(cw CountryWrapper, sw SubDivisionWrapper) map[string]Country {
	countryCodes := getCountryCodes(cw)
	countryMap := make(map[string]Country)

	for _, countryCode := range countryCodes {
		parentStructure := getParentStructure(countryCode, sw)
		parentMap := make(map[string]SubDivision)
		for k, v := range parentStructure { // map[KM:[25 26 27 28 29] VO:[01 02 03 04 05 06 07]]
			tmpSubDiv := make(map[string]SubDivision)
			for _, subCode := range v { // [01 02 03 04 05 06 07]
				tmpSubDiv[subCode] = getSubDivision(countryCode, subCode, sw)
			}
			subDiv := getSubDivision(countryCode, k, sw)
			subDiv.Child = tmpSubDiv
			parentMap[k] = subDiv
		}
		country := getCountry(countryCode, cw)
		country.Child = parentMap
		countryMap[countryCode] = country
	}

	return countryMap
}

func getCountry(countryCode string, cw CountryWrapper) Country {
	for _, country := range cw.Countries {
		if country.Alpha2 == countryCode {
			return country
		}
	}
	panic("not found")
}

func getSubDivision(countryCode, subCode string, sw SubDivisionWrapper) SubDivision {
	for _, subDivision := range sw.SubDivisions {
		if subDivision.Code == countryCode+"-"+subCode {
			return subDivision
		}
	}
	panic("not found")
}

func getParentStructure(countryCode string, sw SubDivisionWrapper) map[string][]string {
	parents := make(map[string][]string)
	for _, sd := range sw.SubDivisions {
		if code := strings.Split(sd.Code, "-"); code[0] == countryCode {
			if sd.Parent != "" {
				parents[sd.Parent] = append(parents[sd.Parent], code[1])
			} else if _, ok := parents[code[1]]; !ok {
				parents[code[1]] = make([]string, 0)
			}
		}
	}
	return parents
}

func getCountryCodes(w CountryWrapper) []string {
	countries := make([]string, 0)
	for _, c := range w.Countries {
		countries = append(countries, c.Alpha2)
	}
	return countries
}

var tmp = `
package cmd

// Code generated by country-states 0.0.1 (https://github.com/hajnalandor/country-states). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

	type Country struct {
		Alpha2       string 
		Alpha3       string 
		Name         string 
		OfficialName string 
		CommonName   string 
		Numeric      string 
		Child        map[string]SubDivision
	}

	type SubDivision struct {
		Name   string 
		Code   string
		Parent string
		Type   string
		Child  map[string]SubDivision
}

	var CountryStates = map[string]Country {
	{{ range $key, $value := . }}
		"{{$key}}": {
			Alpha2:		"{{$value.Alpha2}}",
			Alpha3:		"{{$value.Alpha3}}",
			Name:			"{{$value.Name}}",
			OfficialName:	"{{$value.OfficialName}}",
			CommonName:	"{{$value.CommonName}}",
			Numeric:		"{{$value.Numeric}}",
			{{ if ne (len $value.Child) 0}}
			Child:       map[string]SubDivision{
							{{ range $sk1, $sk2 := $value.Child}}
								"{{$sk1}}": {
									Name:   "{{$sk2.Name}}",
									Code:   "{{$sk2.Code}}",
									Parent: "{{$sk2.Parent}}",
									Type:   "{{$sk2.Type}}",
									{{ if ne (len $sk2.Child) 0}}
									Child:  map[string]SubDivision{
										{{ range $childKey, $childVal := $sk2.Child}}
											"{{$childKey}}": {
												Name:   "{{$childVal.Name}}",
												Code:   "{{$childVal.Code}}",
												Parent: "{{$childVal.Parent}}",
												Type:   "{{$childVal.Type}}",
											},
										{{- end}}
										},
									{{- end}}
								},
							{{- end}}
							},
			{{- end}}
		},
	{{ end }}

	}
`

func Generate(temp map[string]Country) {
	tmpl, err := template.New("generator").Parse(tmp)
	if err != nil {
		panic(err)
	}

	f, err := os.Create("../../country-states.go")
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, temp)
	if err != nil {
		panic(err)
	}
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	_,err = f.Write(formatted)
	if err != nil {
		panic(err)
	}
}
